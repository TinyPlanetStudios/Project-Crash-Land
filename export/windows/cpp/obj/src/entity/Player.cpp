// Generated by Haxe 3.3.0
#include <hxcpp.h>

#ifndef INCLUDED_Global
#include <Global.h>
#endif
#ifndef INCLUDED_GravZone
#include <GravZone.h>
#endif
#ifndef INCLUDED_entity_Ladder
#include <entity/Ladder.h>
#endif
#ifndef INCLUDED_entity_Player
#include <entity/Player.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_input_FlxKeyManager
#include <flixel/input/FlxKeyManager.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInputManager
#include <flixel/input/IFlxInputManager.h>
#endif
#ifndef INCLUDED_flixel_input_keyboard_FlxKeyboard
#include <flixel/input/keyboard/FlxKeyboard.h>
#endif
#ifndef INCLUDED_flixel_math_FlxPoint
#include <flixel/math/FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_util_FlxPool_flixel_math_FlxPoint
#include <flixel/util/FlxPool_flixel_math_FlxPoint.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPool
#include <flixel/util/IFlxPool.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxPooled
#include <flixel/util/IFlxPooled.h>
#endif

static const Int _hx_array_data_0[] = {
	(Int)37,(Int)65,
};
static const Int _hx_array_data_1[] = {
	(Int)39,(Int)68,
};
static const Int _hx_array_data_2[] = {
	(Int)32,
};
static const Int _hx_array_data_3[] = {
	(Int)38,(Int)87,
};
namespace entity{

void Player_obj::__construct( ::Dynamic __o_X, ::Dynamic __o_Y, ::Dynamic SimpleGraphic){
 ::Dynamic X = __o_X.Default(0);
 ::Dynamic Y = __o_Y.Default(0);
            	HX_STACK_FRAME("entity.Player","new",0xffff645e,"entity.Player.new","entity/Player.hx",12,0x10a648b1)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(X,"X")
            	HX_STACK_ARG(Y,"Y")
            	HX_STACK_ARG(SimpleGraphic,"SimpleGraphic")
HXLINE(  22)		this->IgnoreGravity = false;
HXLINE(  20)		this->radialVel = ((Float)0);
HXLINE(  19)		this->angleVel = ((Float)0);
HXLINE(  18)		this->radialPos = ((Float)0);
HXLINE(  17)		this->anglePos = ((Float)20);
HXLINE(  15)		this->speed = (int)-40;
HXLINE(  14)		this->gravity = (int)160;
HXLINE(  37)		super::__construct(X,Y,HX_("assets/images/player.png",87,88,81,c6));
HXLINE(  38)		::Global_obj::Surface = ((Float)::Global_obj::PlanetSize->x / (Float)(int)2);
HXLINE(  39)		this->radialPos = ::Global_obj::Surface;
HXLINE(  41)		this->Ladders = ::Array_obj< ::Dynamic>::__new();
HXLINE(  42)		Float _hx_tmp = (::Global_obj::Surface + (int)5);
HXDLIN(  42)		this->Ladders->push( ::entity::Ladder_obj::__new((int)90,(int)190,_hx_tmp));
HXLINE(  43)		this->Ladders->push( ::entity::Ladder_obj::__new((int)290,(int)190,::Global_obj::Surface));
HXLINE(  44)		this->Ladders->push( ::entity::Ladder_obj::__new((int)340,(int)115,(int)210));
HXLINE(  46)		this->GravZones = ::Array_obj< ::Dynamic>::__new();
HXLINE(  48)		Float _hx_tmp1 = (((Float)::Global_obj::PlanetSize->x / (Float)(int)2) + (int)20);
HXDLIN(  48)		this->GravZones->push( ::GravZone_obj::__new((int)85,(int)95,(int)210,_hx_tmp1,true,true,true,false));
HXLINE(  49)		this->GravZones->push( ::GravZone_obj::__new((int)63,(int)85,(int)190,(int)210,false,false,true,true));
HXLINE(  50)		this->GravZones->push( ::GravZone_obj::__new((int)85,(int)95,(int)190,(int)210,false,false,false,false));
HXLINE(  51)		this->RockWall =  ::GravZone_obj::__new((int)95,(int)100,(int)190,(int)210,false,true,false,true);
HXLINE(  52)		this->GravZones->push(this->RockWall);
HXLINE(  53)		this->GravZones->push( ::GravZone_obj::__new((int)95,(int)130,(int)190,(int)210,false,true,false,true));
HXLINE(  55)		Float _hx_tmp2 = ::Global_obj::Surface;
HXDLIN(  55)		Float _hx_tmp3 = (::Global_obj::Surface + (int)20);
HXDLIN(  55)		this->TrapDoor =  ::GravZone_obj::__new((int)290,(int)295,_hx_tmp2,_hx_tmp3,false,false,false,false);
HXLINE(  56)		this->GravZones->push(this->TrapDoor);
HXLINE(  57)		Float _hx_tmp4 = (::Global_obj::Surface + (int)1);
HXDLIN(  57)		this->GravZones->push( ::GravZone_obj::__new((int)290,(int)295,(int)210,_hx_tmp4,true,true,true,false));
HXLINE(  58)		this->GravZones->push( ::GravZone_obj::__new((int)290,(int)295,(int)190,(int)210,false,false,false,false));
HXLINE(  59)		this->GravZones->push( ::GravZone_obj::__new((int)270,(int)295,(int)190,(int)210,false,false,true,true));
HXLINE(  60)		this->KeyDoor =  ::GravZone_obj::__new((int)300,(int)302,(int)190,(int)210,false,true,false,true);
HXLINE(  61)		this->GravZones->push(this->KeyDoor);
HXLINE(  62)		this->GravZones->push( ::GravZone_obj::__new((int)305,(int)340,(int)190,(int)210,false,false,false,true));
HXLINE(  63)		this->GravZones->push( ::GravZone_obj::__new((int)340,(int)346,(int)190,(int)210,true,false,false,true));
HXLINE(  64)		this->GravZones->push( ::GravZone_obj::__new((int)340,(int)346,(int)130,(int)190,true,true,true,false));
HXLINE(  65)		this->GravZones->push( ::GravZone_obj::__new((int)290,(int)340,(int)115,(int)130,false,false,true,true));
HXLINE(  66)		this->GravZones->push( ::GravZone_obj::__new((int)340,(int)346,(int)115,(int)130,false,true,false,false));
HXLINE(  67)		this->CodeDoor =  ::GravZone_obj::__new((int)345,(int)355,(int)190,(int)210,false,true,false,true);
HXLINE(  68)		this->GravZones->push(this->CodeDoor);
HXLINE(  69)		this->GravZones->push( ::GravZone_obj::__new((int)355,(int)360,(int)190,(int)210,false,false,false,true));
HXLINE(  70)		this->GravZones->push( ::GravZone_obj::__new((int)0,(int)15,(int)190,(int)210,false,true,false,true));
HXLINE(  72)		Float _hx_tmp5 = ::Global_obj::Surface;
HXDLIN(  72)		Float _hx_tmp6 = (::Global_obj::Surface + (int)100);
HXDLIN(  72)		this->CurrentZone =  ::GravZone_obj::__new((int)-1,(int)361,_hx_tmp5,_hx_tmp6,false,false,false,true);
            	}

Dynamic Player_obj::__CreateEmpty() { return new Player_obj; }

hx::ObjectPtr< Player_obj > Player_obj::__new( ::Dynamic __o_X, ::Dynamic __o_Y, ::Dynamic SimpleGraphic)
{
	hx::ObjectPtr< Player_obj > _hx_result = new Player_obj();
	_hx_result->__construct(__o_X,__o_Y,SimpleGraphic);
	return _hx_result;
}

Dynamic Player_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Player_obj > _hx_result = new Player_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2]);
	return _hx_result;
}

void Player_obj::update(Float elapsed){
            	HX_STACK_FRAME("entity.Player","update",0x367c04cb,"entity.Player.update","entity/Player.hx",76,0x10a648b1)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(elapsed,"elapsed")
HXLINE(  77)		this->super::update(elapsed);
HXLINE(  80)		Bool _hx_tmp = !(this->IgnoreGravity);
HXDLIN(  80)		if (_hx_tmp) {
HXLINE(  82)			hx::SubEq(this->radialVel,(this->gravity * elapsed));
            		}
HXLINE(  85)		Bool _hx_tmp1;
HXDLIN(  85)		if (((this->radialPos - (this->radialVel * elapsed)) <= (this->CurrentZone->radialStart + (int)1))) {
HXLINE(  85)			_hx_tmp1 = !(this->CurrentZone->DropThrough);
            		}
            		else {
HXLINE(  85)			_hx_tmp1 = false;
            		}
HXDLIN(  85)		if (_hx_tmp1) {
HXLINE(  87)			this->radialVel = (int)0;
HXLINE(  88)			this->radialPos = this->CurrentZone->radialStart;
            		}
HXLINE(  92)		Bool _hx_tmp2;
HXDLIN(  92)		Bool _hx_tmp3;
HXDLIN(  92)		Bool _hx_tmp4;
HXDLIN(  92)		Bool _hx_tmp5;
HXDLIN(  92)		Bool _hx_tmp6;
HXDLIN(  92)		if ((this->radialPos >= this->CurrentZone->radialStart)) {
HXLINE(  92)			_hx_tmp6 = (this->radialPos <= this->CurrentZone->radialEnd);
            		}
            		else {
HXLINE(  92)			_hx_tmp6 = false;
            		}
HXDLIN(  92)		if (_hx_tmp6) {
HXLINE(  92)			_hx_tmp5 = (this->anglePos <= this->CurrentZone->angleEnd);
            		}
            		else {
HXLINE(  92)			_hx_tmp5 = false;
            		}
HXDLIN(  92)		if (_hx_tmp5) {
HXLINE(  92)			_hx_tmp4 = (this->anglePos >= this->CurrentZone->angleStart);
            		}
            		else {
HXLINE(  92)			_hx_tmp4 = false;
            		}
HXDLIN(  92)		if (!(!(_hx_tmp4))) {
HXLINE(  93)			if ((this->anglePos > (int)85)) {
HXLINE(  92)				_hx_tmp3 = (this->anglePos < (int)95);
            			}
            			else {
HXLINE(  92)				_hx_tmp3 = false;
            			}
            		}
            		else {
HXLINE(  92)			_hx_tmp3 = true;
            		}
HXDLIN(  92)		if (!(_hx_tmp3)) {
HXLINE(  93)			if ((this->anglePos < (int)295)) {
HXLINE(  92)				_hx_tmp2 = (this->anglePos > (int)285);
            			}
            			else {
HXLINE(  92)				_hx_tmp2 = false;
            			}
            		}
            		else {
HXLINE(  92)			_hx_tmp2 = true;
            		}
HXDLIN(  92)		if (_hx_tmp2) {
HXLINE(  95)			this->CurrentZone = this->getCurrentGravZone();
            		}
HXLINE(  98)		Float _hx_tmp7 = this->radialPos;
HXDLIN(  98)		Float _hx_tmp8 = this->get_width();
HXDLIN(  98)		HX_VARI(  ::flixel::math::FlxPoint,Transform) =  ::flixel::math::FlxPoint_obj::__new((int)0,(_hx_tmp7 + ((Float)_hx_tmp8 / (Float)(int)2)));
HXLINE(  99)		HX_VARI(  ::flixel::math::FlxPoint,point) = ::flixel::math::FlxPoint_obj::_pool->get()->set((int)0,(int)0);
HXDLIN(  99)		point->_inPool = false;
HXDLIN(  99)		point->_weak = true;
HXDLIN(  99)		Transform->rotate(point,-(this->anglePos));
HXLINE( 100)		Float _hx_tmp9 = (::Global_obj::PlanetPos->x - Transform->x);
HXDLIN( 100)		Float _hx_tmp10 = this->get_width();
HXDLIN( 100)		Float _hx_tmp11 = (_hx_tmp9 - ((Float)_hx_tmp10 / (Float)(int)2));
HXDLIN( 100)		Float _hx_tmp12 = (::Global_obj::PlanetPos->y - Transform->y);
HXDLIN( 100)		Float _hx_tmp13 = this->get_width();
HXDLIN( 100)		this->setPosition(_hx_tmp11,(_hx_tmp12 - ((Float)_hx_tmp13 / (Float)(int)2)));
HXLINE( 103)		Bool _hx_tmp14 = ::flixel::FlxG_obj::keys->checkKeyArrayState(::Array_obj< Int >::fromData( _hx_array_data_0,2),(int)1);
HXDLIN( 103)		if (_hx_tmp14) {
HXLINE( 105)			this->angleVel = -(this->speed);
            		}
            		else {
HXLINE( 107)			Bool _hx_tmp15 = ::flixel::FlxG_obj::keys->checkKeyArrayState(::Array_obj< Int >::fromData( _hx_array_data_1,2),(int)1);
HXDLIN( 107)			if (_hx_tmp15) {
HXLINE( 109)				this->angleVel = this->speed;
            			}
            			else {
HXLINE( 113)				this->angleVel = (int)0;
            			}
            		}
HXLINE( 117)		Bool _hx_tmp16;
HXDLIN( 117)		Bool _hx_tmp17;
HXDLIN( 117)		if ((this->angleVel < (int)0)) {
HXLINE( 117)			_hx_tmp17 = ((this->anglePos + (this->angleVel * elapsed)) < this->CurrentZone->angleStart);
            		}
            		else {
HXLINE( 117)			_hx_tmp17 = false;
            		}
HXDLIN( 117)		if (_hx_tmp17) {
HXLINE( 117)			_hx_tmp16 = this->CurrentZone->RightWall;
            		}
            		else {
HXLINE( 117)			_hx_tmp16 = false;
            		}
HXDLIN( 117)		if (_hx_tmp16) {
HXLINE( 119)			this->angleVel = (int)0;
            		}
            		else {
HXLINE( 121)			Bool _hx_tmp18;
HXDLIN( 121)			Bool _hx_tmp19;
HXDLIN( 121)			if ((this->angleVel > (int)0)) {
HXLINE( 121)				_hx_tmp19 = ((this->anglePos + (this->angleVel * elapsed)) > this->CurrentZone->angleEnd);
            			}
            			else {
HXLINE( 121)				_hx_tmp19 = false;
            			}
HXDLIN( 121)			if (_hx_tmp19) {
HXLINE( 121)				_hx_tmp18 = this->CurrentZone->LeftWall;
            			}
            			else {
HXLINE( 121)				_hx_tmp18 = false;
            			}
HXDLIN( 121)			if (_hx_tmp18) {
HXLINE( 123)				this->angleVel = (int)0;
            			}
            		}
HXLINE( 127)		Bool _hx_tmp20;
HXDLIN( 127)		Bool _hx_tmp21;
HXDLIN( 127)		if ((this->radialVel != (int)0)) {
HXLINE( 127)			_hx_tmp21 = this->IgnoreGravity;
            		}
            		else {
HXLINE( 127)			_hx_tmp21 = true;
            		}
HXDLIN( 127)		if (_hx_tmp21) {
HXLINE( 127)			_hx_tmp20 = ::flixel::FlxG_obj::keys->checkKeyArrayState(::Array_obj< Int >::fromData( _hx_array_data_2,1),(int)2);
            		}
            		else {
HXLINE( 127)			_hx_tmp20 = false;
            		}
HXDLIN( 127)		if (_hx_tmp20) {
HXLINE( 129)			this->radialVel = (int)100;
HXLINE( 130)			hx::AddEq(this->radialPos,(int)2);
            		}
HXLINE( 134)		Bool _hx_tmp22;
HXDLIN( 134)		Bool _hx_tmp23 = ::flixel::FlxG_obj::keys->checkKeyArrayState(::Array_obj< Int >::fromData( _hx_array_data_3,2),(int)1);
HXDLIN( 134)		if (_hx_tmp23) {
HXLINE( 134)			_hx_tmp22 = this->OnLadder();
            		}
            		else {
HXLINE( 134)			_hx_tmp22 = false;
            		}
HXDLIN( 134)		if (_hx_tmp22) {
HXLINE( 136)			hx::AddEq(this->radialPos,(int)2);
HXLINE( 137)			Bool _hx_tmp24 = (this->radialVel < (int)20);
HXDLIN( 137)			if (_hx_tmp24) {
HXLINE( 139)				this->radialVel = (int)20;
            			}
HXLINE( 141)			this->IgnoreGravity = true;
            		}
            		else {
HXLINE( 145)			this->IgnoreGravity = false;
            		}
HXLINE( 150)		Bool _hx_tmp25;
HXDLIN( 150)		if (((this->radialPos + (this->radialVel * elapsed)) > this->CurrentZone->radialEnd)) {
HXLINE( 150)			_hx_tmp25 = this->CurrentZone->Ceiling;
            		}
            		else {
HXLINE( 150)			_hx_tmp25 = false;
            		}
HXDLIN( 150)		if (_hx_tmp25) {
HXLINE( 152)			this->radialVel = (int)0;
HXLINE( 153)			this->radialPos = this->CurrentZone->radialEnd;
            		}
HXLINE( 157)		Bool _hx_tmp26 = ::Global_obj::Halt;
HXDLIN( 157)		if (_hx_tmp26) {
HXLINE( 159)			this->angleVel = (int)0;
            		}
HXLINE( 163)		hx::AddEq(this->radialPos,(this->radialVel * elapsed));
HXLINE( 164)		Bool _hx_tmp27 = (this->anglePos < (int)0);
HXDLIN( 164)		if (_hx_tmp27) {
HXLINE( 166)			hx::AddEq(this->anglePos,(int)360);
            		}
            		else {
HXLINE( 168)			Bool _hx_tmp28 = (this->anglePos > (int)360);
HXDLIN( 168)			if (_hx_tmp28) {
HXLINE( 170)				hx::SubEq(this->anglePos,(int)360);
            			}
            		}
HXLINE( 172)		hx::AddEq(this->anglePos,(this->angleVel * elapsed));
            	}


 ::GravZone Player_obj::getCurrentGravZone(){
            	HX_STACK_FRAME("entity.Player","getCurrentGravZone",0xa6c50151,"entity.Player.getCurrentGravZone","entity/Player.hx",176,0x10a648b1)
            	HX_STACK_THIS(this)
HXLINE( 177)		{
HXLINE( 177)			HX_VARI( Int,_g) = (int)0;
HXDLIN( 177)			HX_VARI( ::Array< ::Dynamic>,_g1) = this->GravZones;
HXDLIN( 177)			while((_g < _g1->length)){
HXLINE( 177)				HX_VARI(  ::GravZone,a) = _g1->__get(_g).StaticCast<  ::GravZone >();
HXDLIN( 177)				++_g;
HXLINE( 179)				Bool _hx_tmp;
HXDLIN( 179)				Bool _hx_tmp1;
HXDLIN( 179)				Bool _hx_tmp2;
HXDLIN( 179)				if ((this->radialPos >= a->radialStart)) {
HXLINE( 179)					_hx_tmp2 = (this->radialPos <= a->radialEnd);
            				}
            				else {
HXLINE( 179)					_hx_tmp2 = false;
            				}
HXDLIN( 179)				if (_hx_tmp2) {
HXLINE( 179)					_hx_tmp1 = (this->anglePos <= a->angleEnd);
            				}
            				else {
HXLINE( 179)					_hx_tmp1 = false;
            				}
HXDLIN( 179)				if (_hx_tmp1) {
HXLINE( 179)					_hx_tmp = (this->anglePos >= a->angleStart);
            				}
            				else {
HXLINE( 179)					_hx_tmp = false;
            				}
HXDLIN( 179)				if (_hx_tmp) {
HXLINE( 182)					return a;
            				}
            			}
            		}
HXLINE( 185)		if ((this->radialPos >= this->CurrentZone->radialEnd)) {
HXLINE( 187)			return  ::GravZone_obj::__new((int)-1,(int)361,::Global_obj::Surface,(::Global_obj::Surface + (int)100),false,false,false,true);
            		}
HXLINE( 189)		return this->CurrentZone;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Player_obj,getCurrentGravZone,return )

Bool Player_obj::OnLadder(){
            	HX_STACK_FRAME("entity.Player","OnLadder",0x5d52b2c3,"entity.Player.OnLadder","entity/Player.hx",193,0x10a648b1)
            	HX_STACK_THIS(this)
HXLINE( 194)		{
HXLINE( 194)			HX_VARI( Int,_g) = (int)0;
HXDLIN( 194)			HX_VARI( ::Array< ::Dynamic>,_g1) = this->Ladders;
HXDLIN( 194)			while((_g < _g1->length)){
HXLINE( 194)				HX_VARI(  ::entity::Ladder,a) = _g1->__get(_g).StaticCast<  ::entity::Ladder >();
HXDLIN( 194)				++_g;
HXLINE( 196)				Bool _hx_tmp;
HXDLIN( 196)				Bool _hx_tmp1;
HXDLIN( 196)				Bool _hx_tmp2;
HXDLIN( 196)				if ((this->radialPos >= a->radialStart)) {
HXLINE( 196)					_hx_tmp2 = (this->radialPos <= a->radialEnd);
            				}
            				else {
HXLINE( 196)					_hx_tmp2 = false;
            				}
HXDLIN( 196)				if (_hx_tmp2) {
HXLINE( 196)					_hx_tmp1 = (this->anglePos <= (a->Angle + (int)2));
            				}
            				else {
HXLINE( 196)					_hx_tmp1 = false;
            				}
HXDLIN( 196)				if (_hx_tmp1) {
HXLINE( 196)					_hx_tmp = (this->anglePos >= (a->Angle - (int)2));
            				}
            				else {
HXLINE( 196)					_hx_tmp = false;
            				}
HXDLIN( 196)				if (_hx_tmp) {
HXLINE( 199)					return true;
            				}
            			}
            		}
HXLINE( 202)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Player_obj,OnLadder,return )


Player_obj::Player_obj()
{
}

void Player_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Player);
	HX_MARK_MEMBER_NAME(gravity,"gravity");
	HX_MARK_MEMBER_NAME(speed,"speed");
	HX_MARK_MEMBER_NAME(anglePos,"anglePos");
	HX_MARK_MEMBER_NAME(radialPos,"radialPos");
	HX_MARK_MEMBER_NAME(angleVel,"angleVel");
	HX_MARK_MEMBER_NAME(radialVel,"radialVel");
	HX_MARK_MEMBER_NAME(IgnoreGravity,"IgnoreGravity");
	HX_MARK_MEMBER_NAME(GravZones,"GravZones");
	HX_MARK_MEMBER_NAME(CurrentZone,"CurrentZone");
	HX_MARK_MEMBER_NAME(RockWall,"RockWall");
	HX_MARK_MEMBER_NAME(TrapDoor,"TrapDoor");
	HX_MARK_MEMBER_NAME(KeyDoor,"KeyDoor");
	HX_MARK_MEMBER_NAME(CodeDoor,"CodeDoor");
	HX_MARK_MEMBER_NAME(Ladders,"Ladders");
	 ::flixel::FlxSprite_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void Player_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(gravity,"gravity");
	HX_VISIT_MEMBER_NAME(speed,"speed");
	HX_VISIT_MEMBER_NAME(anglePos,"anglePos");
	HX_VISIT_MEMBER_NAME(radialPos,"radialPos");
	HX_VISIT_MEMBER_NAME(angleVel,"angleVel");
	HX_VISIT_MEMBER_NAME(radialVel,"radialVel");
	HX_VISIT_MEMBER_NAME(IgnoreGravity,"IgnoreGravity");
	HX_VISIT_MEMBER_NAME(GravZones,"GravZones");
	HX_VISIT_MEMBER_NAME(CurrentZone,"CurrentZone");
	HX_VISIT_MEMBER_NAME(RockWall,"RockWall");
	HX_VISIT_MEMBER_NAME(TrapDoor,"TrapDoor");
	HX_VISIT_MEMBER_NAME(KeyDoor,"KeyDoor");
	HX_VISIT_MEMBER_NAME(CodeDoor,"CodeDoor");
	HX_VISIT_MEMBER_NAME(Ladders,"Ladders");
	 ::flixel::FlxSprite_obj::__Visit(HX_VISIT_ARG);
}

hx::Val Player_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"speed") ) { return hx::Val( speed); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"update") ) { return hx::Val( update_dyn()); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"gravity") ) { return hx::Val( gravity); }
		if (HX_FIELD_EQ(inName,"KeyDoor") ) { return hx::Val( KeyDoor); }
		if (HX_FIELD_EQ(inName,"Ladders") ) { return hx::Val( Ladders); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"anglePos") ) { return hx::Val( anglePos); }
		if (HX_FIELD_EQ(inName,"angleVel") ) { return hx::Val( angleVel); }
		if (HX_FIELD_EQ(inName,"RockWall") ) { return hx::Val( RockWall); }
		if (HX_FIELD_EQ(inName,"TrapDoor") ) { return hx::Val( TrapDoor); }
		if (HX_FIELD_EQ(inName,"CodeDoor") ) { return hx::Val( CodeDoor); }
		if (HX_FIELD_EQ(inName,"OnLadder") ) { return hx::Val( OnLadder_dyn()); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"radialPos") ) { return hx::Val( radialPos); }
		if (HX_FIELD_EQ(inName,"radialVel") ) { return hx::Val( radialVel); }
		if (HX_FIELD_EQ(inName,"GravZones") ) { return hx::Val( GravZones); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"CurrentZone") ) { return hx::Val( CurrentZone); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"IgnoreGravity") ) { return hx::Val( IgnoreGravity); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"getCurrentGravZone") ) { return hx::Val( getCurrentGravZone_dyn()); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val Player_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"speed") ) { speed=inValue.Cast< Int >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"gravity") ) { gravity=inValue.Cast< Int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"KeyDoor") ) { KeyDoor=inValue.Cast<  ::GravZone >(); return inValue; }
		if (HX_FIELD_EQ(inName,"Ladders") ) { Ladders=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"anglePos") ) { anglePos=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"angleVel") ) { angleVel=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"RockWall") ) { RockWall=inValue.Cast<  ::GravZone >(); return inValue; }
		if (HX_FIELD_EQ(inName,"TrapDoor") ) { TrapDoor=inValue.Cast<  ::GravZone >(); return inValue; }
		if (HX_FIELD_EQ(inName,"CodeDoor") ) { CodeDoor=inValue.Cast<  ::GravZone >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"radialPos") ) { radialPos=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"radialVel") ) { radialVel=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"GravZones") ) { GravZones=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"CurrentZone") ) { CurrentZone=inValue.Cast<  ::GravZone >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"IgnoreGravity") ) { IgnoreGravity=inValue.Cast< Bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Player_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("gravity","\x4e","\x6e","\xff","\x77"));
	outFields->push(HX_HCSTRING("speed","\x87","\x97","\x69","\x81"));
	outFields->push(HX_HCSTRING("anglePos","\x81","\xb7","\x5e","\x2b"));
	outFields->push(HX_HCSTRING("radialPos","\xf5","\xab","\xf7","\xf6"));
	outFields->push(HX_HCSTRING("angleVel","\x4a","\x3c","\x63","\x2b"));
	outFields->push(HX_HCSTRING("radialVel","\xbe","\x30","\xfc","\xf6"));
	outFields->push(HX_HCSTRING("IgnoreGravity","\x3c","\x53","\x7d","\xdd"));
	outFields->push(HX_HCSTRING("GravZones","\xa7","\x38","\xec","\x04"));
	outFields->push(HX_HCSTRING("CurrentZone","\xe5","\x12","\xbd","\x6d"));
	outFields->push(HX_HCSTRING("RockWall","\x6f","\x5f","\xf7","\xc4"));
	outFields->push(HX_HCSTRING("TrapDoor","\x1b","\x6a","\xe2","\xbb"));
	outFields->push(HX_HCSTRING("KeyDoor","\x8d","\x8a","\x98","\x69"));
	outFields->push(HX_HCSTRING("CodeDoor","\x5b","\x25","\x72","\x50"));
	outFields->push(HX_HCSTRING("Ladders","\x31","\xa1","\x75","\xf7"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo Player_obj_sMemberStorageInfo[] = {
	{hx::fsInt,(int)offsetof(Player_obj,gravity),HX_HCSTRING("gravity","\x4e","\x6e","\xff","\x77")},
	{hx::fsInt,(int)offsetof(Player_obj,speed),HX_HCSTRING("speed","\x87","\x97","\x69","\x81")},
	{hx::fsFloat,(int)offsetof(Player_obj,anglePos),HX_HCSTRING("anglePos","\x81","\xb7","\x5e","\x2b")},
	{hx::fsFloat,(int)offsetof(Player_obj,radialPos),HX_HCSTRING("radialPos","\xf5","\xab","\xf7","\xf6")},
	{hx::fsFloat,(int)offsetof(Player_obj,angleVel),HX_HCSTRING("angleVel","\x4a","\x3c","\x63","\x2b")},
	{hx::fsFloat,(int)offsetof(Player_obj,radialVel),HX_HCSTRING("radialVel","\xbe","\x30","\xfc","\xf6")},
	{hx::fsBool,(int)offsetof(Player_obj,IgnoreGravity),HX_HCSTRING("IgnoreGravity","\x3c","\x53","\x7d","\xdd")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(Player_obj,GravZones),HX_HCSTRING("GravZones","\xa7","\x38","\xec","\x04")},
	{hx::fsObject /*::GravZone*/ ,(int)offsetof(Player_obj,CurrentZone),HX_HCSTRING("CurrentZone","\xe5","\x12","\xbd","\x6d")},
	{hx::fsObject /*::GravZone*/ ,(int)offsetof(Player_obj,RockWall),HX_HCSTRING("RockWall","\x6f","\x5f","\xf7","\xc4")},
	{hx::fsObject /*::GravZone*/ ,(int)offsetof(Player_obj,TrapDoor),HX_HCSTRING("TrapDoor","\x1b","\x6a","\xe2","\xbb")},
	{hx::fsObject /*::GravZone*/ ,(int)offsetof(Player_obj,KeyDoor),HX_HCSTRING("KeyDoor","\x8d","\x8a","\x98","\x69")},
	{hx::fsObject /*::GravZone*/ ,(int)offsetof(Player_obj,CodeDoor),HX_HCSTRING("CodeDoor","\x5b","\x25","\x72","\x50")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(Player_obj,Ladders),HX_HCSTRING("Ladders","\x31","\xa1","\x75","\xf7")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *Player_obj_sStaticStorageInfo = 0;
#endif

static ::String Player_obj_sMemberFields[] = {
	HX_HCSTRING("gravity","\x4e","\x6e","\xff","\x77"),
	HX_HCSTRING("speed","\x87","\x97","\x69","\x81"),
	HX_HCSTRING("anglePos","\x81","\xb7","\x5e","\x2b"),
	HX_HCSTRING("radialPos","\xf5","\xab","\xf7","\xf6"),
	HX_HCSTRING("angleVel","\x4a","\x3c","\x63","\x2b"),
	HX_HCSTRING("radialVel","\xbe","\x30","\xfc","\xf6"),
	HX_HCSTRING("IgnoreGravity","\x3c","\x53","\x7d","\xdd"),
	HX_HCSTRING("GravZones","\xa7","\x38","\xec","\x04"),
	HX_HCSTRING("CurrentZone","\xe5","\x12","\xbd","\x6d"),
	HX_HCSTRING("RockWall","\x6f","\x5f","\xf7","\xc4"),
	HX_HCSTRING("TrapDoor","\x1b","\x6a","\xe2","\xbb"),
	HX_HCSTRING("KeyDoor","\x8d","\x8a","\x98","\x69"),
	HX_HCSTRING("CodeDoor","\x5b","\x25","\x72","\x50"),
	HX_HCSTRING("Ladders","\x31","\xa1","\x75","\xf7"),
	HX_HCSTRING("update","\x09","\x86","\x05","\x87"),
	HX_HCSTRING("getCurrentGravZone","\x8f","\x67","\xaa","\x04"),
	HX_HCSTRING("OnLadder","\x81","\x7f","\x2d","\x04"),
	::String(null()) };

static void Player_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Player_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Player_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Player_obj::__mClass,"__mClass");
};

#endif

hx::Class Player_obj::__mClass;

void Player_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("entity.Player","\x6c","\x9d","\xea","\x8b");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = Player_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Player_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Player_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Player_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Player_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Player_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace entity
